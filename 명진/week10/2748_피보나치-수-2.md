# [2748 - 피보나치 수 2](https://www.acmicpc.net/problem/2748)

## 문제 이해

DP의 핵심 개념인 **메모이제이션** 또는 **타뷸레이션** 연습문제.

> **메모이제이션** : 반복되어 재사용 되는 값을 저장해두어 중복 연산을 피하는 기법 \
> **타뷸레이션** : 테이블(표)를 활용해 작은 값들을 조합해 큰 값을 만든다.

## 접근 및 풀이

### 재귀 구현

```python
def fibonacci(n):
    if n <= 1: return n
    return fibonacci(n-1) + fibonacci(n-2)
print(fibonacci(int(input())))
```

```cpp
int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n-1) + fibonacci(n-2);
}
```

이런 구현은 당연하게도 _시간초과_
`fibonacci(n)`이 이미 계산된 적이 있으면 그 값을 갖다 쓰도록 추가해주면 된다. (메모이제이션)

```cpp
int N;
ll memo[MAX_N];

ll fibonacci(int n) {
  if (n <= 1)
    return n;
  if (memo[n] != -1)
    return memo[n];
  return memo[n] = fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
  cin >> N;
  memset(memo, -1, sizeof(memo));
  cout << fibonacci(N);
}
```

파이썬에서는 일종의 잡기술로 cache 데코레이터를 활용해주면 함수의 인자와 리턴값을 매칭해 알아서 캐시한 후 재활용한다.

```python
from functools import cache

@cache
def fibonacci(n):
    if n <= 1: return n
    return fibonacci(n-1) + fibonacci(n-2)
print(fibonacci(int(input())))
```

재귀 + 메모이제이션을 이용해 위에서부터 쪼개가면서 해결하는 방법을 탑다운 dp라고도 한다.
장점은 문제에 따라 직관적일 수 있다는 것, 하지만 재귀이기에 함수 오버헤드가 존재함.
파이썬의 경우 재귀 깊이 제한을 풀어주어야 할 수도 있음

## 타뷸레이션

```python
fib = [0, 1]+[0]*99
n = int(input())
for i in range(2, n+1):
    fib[i] = fib[i-1] + fib[i-2]
print(fib[n])
```

이렇게 구현했다면 타뷸레이션. 동적계획법의 문제 풀이에 특수한 경우를 제외하면 점화식을 세우고 타뷸레이션으로 해결하는 경우가 많기에 이후 풀이는 타뷸레이션으로 진행.
